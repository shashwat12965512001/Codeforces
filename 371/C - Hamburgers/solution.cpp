#include <bits/stdc++.h>using namespace std; // ================= SPEED =================#define fastio()                      \    ios_base::sync_with_stdio(false); \    cin.tie(nullptr);                 \    cout.tie(nullptr); // ================= MACROS =================#define PI 3.141592653589#define M 1000000007#define pb push_back#define f first#define se second#define all(x) x.begin(), x.end()#define rep(i, n) for (int i = 0; i < (n); i++)#define rrep(i, n) for (int i = (n); i >= 0; i--)#define inint(x) \    int x;       \    cin >> x#define inll(x) \    ll x;       \    cin >> x#define instr(x) \    string x;    \    cin >> x // ================= TYPEDEFS =================typedef long long ll;typedef unsigned long long ull;typedef long double lld;typedef pair<int, int> pi;typedef pair<ll, ll> pl;typedef vector<int> vi;typedef vector<ll> vl;typedef vector<pi> vpi;typedef vector<vi> vvi;typedef vector<vl> vvl; // ================= DEBUG =================#ifndef ONLINE_JUDGE#define debug(x)         \    cerr << #x << " = "; \    _print(x);           \    cerr << '\n';#else#define debug(x)#endifvoid _print(ll t) { cerr << t; }void _print(int t) { cerr << t; }void _print(string t) { cerr << t; }void _print(char t) { cerr << t; }void _print(double t) { cerr << t; } // ================= VECTOR I/O =================template <typename T>istream &operator>>(istream &in, vector<T> &v){    for (auto &it : v)        in >> it;    return in;}template <typename T>ostream &operator<<(ostream &out, const vector<T> &v){    for (auto &it : v)        out << it << " ";    return out;} // ================= NUMBER THEORY =================ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }bool isPrime(ll n){    if (n < 2)        return false;    if (n == 2)        return true;    if (n % 2 == 0)        return false;    for (ll i = 3; i * i <= n; i += 2)        if (n % i == 0)            return false;    return true;}vi getPrimeFactors(int n){    vi factors;    for (int d = 2; d * d <= n; d++)    {        if (n % d == 0)        {            factors.pb(d);            while (n % d == 0)                n /= d;        }    }    if (n > 1)        factors.pb(n);    return factors;}vl getFactors(ll n){    vl factors;    for (ll i = 1; i * i <= n; i++)    {        if (n % i == 0)        {            factors.pb(i);            if (i != n / i)                factors.pb(n / i);        }    }    sort(all(factors));    return factors;}bool isPowerOfTwo(ll n) { return n > 0 && (n & (n - 1)) == 0; }int phi_single(int n){    int res = n;    for (int p = 2; p * p <= n; p++)    {        if (n % p == 0)        {            while (n % p == 0)                n /= p;            res -= res / p;        }    }    if (n > 1)        res -= res / n;    return res;}vi phi_sieve(int N){    vi phi(N + 1);    iota(all(phi), 0);    for (int p = 2; p <= N; p++)    {        if (phi[p] == p)            for (int k = p; k <= N; k += p)                phi[k] -= phi[k] / p;    }    return phi;} // ================= BINARY SEARCH =================int lowerBound(const vi &a, int target){    int low = 0, high = a.size() - 1, res = -1;    while (low <= high)    {        int mid = low + (high - low) / 2;        if (a[mid] == target)        {            res = mid;            high = mid - 1;        }        else if (a[mid] < target)            low = mid + 1;        else            high = mid - 1;    }    return res;}int upperBound(const vi &a, int target){    int low = 0, high = a.size() - 1, res = -1;    while (low <= high)    {        int mid = low + (high - low) / 2;        if (a[mid] == target)        {            res = mid;            low = mid + 1;        }        else if (a[mid] < target)            low = mid + 1;        else            high = mid - 1;    }    return res;}int countOccurences(const vi &a, int target){    int first = lowerBound(a, target);    if (first == -1)        return 0;    return upperBound(a, target) - first + 1;} // ================= SORTING =================void bubbleSort(vi &a){    int n = a.size();    rep(i, n - 1)    {        bool swapped = false;        for (int j = 0; j < n - i - 1; j++)        {            if (a[j] > a[j + 1])            {                swap(a[j], a[j + 1]);                swapped = true;            }        }        if (!swapped)            break;    }} void insertionSort(vi &a){    int n = a.size();    for (int i = 1; i < n; i++)    {        int key = a[i];        int j = i - 1;        while (j >= 0 && a[j] > key)        {            a[j + 1] = a[j];            j--;        }        a[j + 1] = key;    }} void selectionSort(vi &a){    int n = a.size();    rep(i, n - 1)    {        int mn = i;        for (int j = i + 1; j < n; j++)        {            if (a[j] < a[mn])                mn = j;        }        swap(a[i], a[mn]);    }} void countingSort(vi &a){    if (a.empty())        return;    int mx = *max_element(all(a));    vi cnt(mx + 1, 0);    for (int x : a)        cnt[x]++;    int idx = 0;    rep(i, mx + 1) while (cnt[i]--) a[idx++] = i;} void merge(vi &a, int l, int m, int r){    int n1 = m - l + 1, n2 = r - m;    vi L(n1), R(n2);    rep(i, n1) L[i] = a[l + i];    rep(i, n2) R[i] = a[m + 1 + i];     int i = 0, j = 0, k = l;    while (i < n1 && j < n2)    {        if (L[i] <= R[j])            a[k++] = L[i++];        else            a[k++] = R[j++];    }    while (i < n1)        a[k++] = L[i++];    while (j < n2)        a[k++] = R[j++];}void mergeSort(vi &a, int l, int r){    if (l < r)    {        int m = l + (r - l) / 2;        mergeSort(a, l, m);        mergeSort(a, m + 1, r);        merge(a, l, m, r);    }} int partitionQ(vi &a, int low, int high){    int pivot = a[high];    int i = low - 1;    for (int j = low; j < high; j++)    {        if (a[j] <= pivot)        {            i++;            swap(a[i], a[j]);        }    }    swap(a[i + 1], a[high]);    return i + 1;}void quickSort(vi &a, int low, int high){    if (low < high)    {        int pi = partitionQ(a, low, high);        quickSort(a, low, pi - 1);        quickSort(a, pi + 1, high);    }} // ================= CONVERSIONS =================string decToBinary(int n){    string s = "";    while (n > 0)    {        s = char('0' + (n % 2)) + s;        n /= 2;    }    return s.empty() ? "0" : s;}int binaryToDec(const string &s){    int n = 0;    for (char c : s)        n = n * 2 + (c - '0');    return n;} // ================= MODULAR ARITH =================ll addmod(ll a, ll b, ll m = M) { return (a % m + b % m) % m; }ll submod(ll a, ll b, ll m = M) { return ((a % m - b % m) + m) % m; }ll mulmod(ll a, ll b, ll m = M) { return ((a % m) * (b % m)) % m; }ll binexp(ll a, ll b, ll m = M){    ll res = 1;    a %= m;    while (b)    {        if (b & 1)            res = (res * a) % m;        a = (a * a) % m;        b >>= 1;    }    return res;}ll modinv(ll a, ll m = M) { return binexp(a, m - 2, m); } // Only if m is prime // ================= COMBINATORICS =================const int MAXN = 2e5 + 5;vl fact(MAXN), invfact(MAXN);void precomputeFactorials(){    fact[0] = invfact[0] = 1;    for (int i = 1; i < MAXN; i++)        fact[i] = (fact[i - 1] * i) % M;    invfact[MAXN - 1] = modinv(fact[MAXN - 1], M);    for (int i = MAXN - 2; i >= 1; i--)        invfact[i] = (invfact[i + 1] * (i + 1)) % M;}ll nCr(ll n, ll r){    if (r > n || n < 0 || r < 0)        return 0;    return fact[n] * invfact[r] % M * invfact[n - r] % M;} // ================= GRAPH =================struct Edge{    int u, v;    ll w;};vvi adj;vl dist;vector<bool> visited; void dfs(int u){    visited[u] = true;    for (int v : adj[u])        if (!visited[v])            dfs(v);}void bfs(int s){    queue<int> q;    q.push(s);    visited.assign(adj.size(), false);    visited[s] = true;    while (!q.empty())    {        int u = q.front();        q.pop();        for (int v : adj[u])            if (!visited[v])            {                visited[v] = true;                q.push(v);            }    }} // Dijkstra (weighted graph)void dijkstra(int src){    dist.assign(adj.size(), LLONG_MAX);    dist[src] = 0;    priority_queue<pl, vector<pl>, greater<pl>> pq;    pq.push({0, src});    while (!pq.empty())    {        auto [d, u] = pq.top();        pq.pop();        if (d > dist[u])            continue;        for (int v : adj[u])        {            ll w = 1;            if (dist[u] + w < dist[v])            {                dist[v] = dist[u] + w;                pq.push({dist[v], v});            }        }    }} // ================= DSU / UNION-FIND =================struct DSU{    vi parent, rank;    DSU(int n)    {        parent.resize(n);        rank.assign(n, 0);        iota(all(parent), 0);    }    int find(int x) { return parent[x] == x ? x : parent[x] = find(parent[x]); }    void unite(int x, int y)    {        x = find(x);        y = find(y);        if (x == y)            return;        if (rank[x] < rank[y])            parent[x] = y;        else if (rank[x] > rank[y])            parent[y] = x;        else        {            parent[y] = x;            rank[x]++;        }    }}; // ================= SEGMENT TREE =================struct SegTree{    int size;    vl tree;    void init(int n)    {        size = 1;        while (size < n)            size *= 2;        tree.assign(2 * size, 0);    }    void build(vl &a, int x, int lx, int rx)    {        if (rx - lx == 1)        {            if (lx < a.size())                tree[x] = a[lx];            return;        }        int m = (lx + rx) / 2;        build(a, 2 * x + 1, lx, m);        build(a, 2 * x + 2, m, rx);        tree[x] = tree[2 * x + 1] + tree[2 * x + 2];    }    void build(vl &a) { build(a, 0, 0, size); }    void set(int i, ll v, int x, int lx, int rx)    {        if (rx - lx == 1)        {            tree[x] = v;            return;        }        int m = (lx + rx) / 2;        if (i < m)            set(i, v, 2 * x + 1, lx, m);        else            set(i, v, 2 * x + 2, m, rx);        tree[x] = tree[2 * x + 1] + tree[2 * x + 2];    }    void set(int i, ll v) { set(i, v, 0, 0, size); }    ll sum(int l, int r, int x, int lx, int rx)    {        if (l >= rx || r <= lx)            return 0;        if (l <= lx && rx <= r)            return tree[x];        int m = (lx + rx) / 2;        return sum(l, r, 2 * x + 1, lx, m) + sum(l, r, 2 * x + 2, m, rx);    }    ll sum(int l, int r) { return sum(l, r, 0, 0, size); }}; // ================= BIT / FENWICK =================struct BIT{    vl tree;    int n;    void init(int size)    {        n = size;        tree.assign(n + 1, 0);    }    void update(int i, ll x)    {        for (; i <= n; i += i & -i)            tree[i] += x;    }    ll query(int i)    {        ll res = 0;        for (; i > 0; i -= i & -i)            res += tree[i];        return res;    }    ll query(int l, int r) { return query(r) - query(l - 1); }}; // ================= SOLVE =================void solve(){    string recipe;    cin >> recipe;     ll nb, ns, nc;    cin >> nb >> ns >> nc;     ll pb, ps, pc;    cin >> pb >> ps >> pc;     ll r;    cin >> r;     ll b = 0, s = 0, c = 0;    for (char ch : recipe)    {        if (ch == 'B')            b++;        else if (ch == 'S')            s++;        else if (ch == 'C')            c++;    }     ll low = 0, high = 1e13, ans = 0;    while (low <= high)    {        ll mid = (low + high) / 2;         ll needB = max(0LL, b * mid - nb);        ll needS = max(0LL, s * mid - ns);        ll needC = max(0LL, c * mid - nc);         __int128 cost = 1LL * needB * pb + 1LL * needS * ps + 1LL * needC * pc;         if (cost <= r)        {            ans = mid;            low = mid + 1;        }        else        {            high = mid - 1;        }    }     cout << ans;    return;} // ================= MAIN =================int main(){    fastio();    // precomputeFactorials();    // inint(t); while(t--) solve();    solve();    return 0;}